'''
Created on Jun 25, 2014

@author: johnny
'''

def create(size):
    '''
    Creates a new ByteBuffer with the given number of bytes available
    '''
    buffObj = bytearray(size)
    return ByteBuffer(buffObj)


class ByteBuffer(object):
    '''
    Since Python does not have any consequent way of handling byte buffers that works
    with Structs, this class has been used to remedy this problem.
    
    A byte buffer is intended to work just as a memory view, but specifically for
    '''

    def __init__(self, byteBuffer, offset = 0, length = -1):
        '''
        Creates a new byte buffer instance. This is a low level constructor,
        which is rarely used directly. Instead you should use the static
        create method, or XXX from an existing ByteBuffer instance.
        
        @param byteBuffer: A bytearray or ByteBuffer instance to make a buffer instance for
        @param offset: The offset to start on in the given buffer
        @param length: The length in the given buffer to end at   
        '''
        # The parent buffer is None by default
        self.parent = None
        
        # Handle wrapping of existing buffers
        if isinstance(byteBuffer, ByteBuffer): 
            self._buffer = byteBuffer._buffer
            offset += byteBuffer.offset
            self.parent = byteBuffer
        else:
            self._buffer = byteBuffer
        
        # Handle length of buffer
        bufferTotLen = len(self._buffer)
        self.length = length if length >= 0 else bufferTotLen - offset
        self.offset = offset
        
        # Sanity check limits
        if self.offset + self.length > bufferTotLen:
            raise IndexError("Offset and Length is out of bounds of the buffer") 
    
    def sub(self, offset = 0, length = -1):
        '''
        Creates a sub buffer of the current buffer that still references the underlying buffer.
        Any changes to the returned buffer will also affect the original buffer.
        
        @param offset: Offset in buffer to start slice from (default 0)
        @param length: Length in buffer to end slice at (default -1, which means to the end)
        '''
        return ByteBuffer(self, offset, length)
    
    def clone(self, offset = 0, length = -1):
        '''
        This does the same as sub(), except it creates a COPY of the data in the 
        underlying buffer, into a new buffer. This means that changes to the resulting
        buffer will NOT affect the original buffer.
        
        @param offset: Offset in THIS buffer to start cloning from (default 0)
        @param length: Length in buffer to end cloning at (default -1, which means to the end)
        '''
        # Make a new buffer and copy the data
        if length < 0: length = self._length - offset
        buffObj = bytearray(length)
        buffObj[0:length] = self._buffer[offset:offset+length]
        return ByteBuffer(buffObj)
    
    def copy(self, srcBuffer, targetOffset = 0, srcOffset = 0, length = -1):
        '''
        Copies data from the given source buffer into this one. The source buffer
        can be either another ByteBuffer instance, a string or bytearray instance.
        
        @param srcBuffer: The source buffer to copy from. 
        @param targetOffset: Offset in this buffer to copy to
        @param srcOffset: Offset in source buffer to start copy from (default 0)
        @param length: Length of data to copy (default -1 which means to the end)
        '''
        # If we have a ByteBuffer instance, we need to modify some references
        if isinstance(srcBuffer, ByteBuffer):
            srcOffset += srcBuffer.offset
            srcBuffer = srcBuffer._buffer
            
        # Calculate length if not specified
        if length < 0: length = len(srcBuffer) - srcOffset
        
        # Copy the data to the absolute offset
        absTargetOffset = self.offset + targetOffset
        self._buffer[absTargetOffset : absTargetOffset + length] = memoryview(srcBuffer)[srcOffset : srcOffset + length]
    
    def swap(self, swap):
        '''
        Swaps the underlying buffer in the given ByteBuffer instance with this one.
        THIS IS NOT THREADSAFE, and needs a threading.Lock() if swapping across 
        different threads.
        
        @param swap: The ByteBuffer to swap with this buffer 
        '''
        if swap.length != self.length:
            temp = self.length
            self.length = swap.length
            swap.length = temp
            
        if swap.offset != self.offset:
            temp = self.offset
            self.offset = swap.offset
            swap.offset = temp
        
        if not (swap._buffer is self._buffer):
            temp = self._buffer    
            self._buffer = swap._buffer
            swap._buffer = temp
        
    def pack(self, structObj, offset, *args):
        '''
        Used to struct.pack data into this buffer at the given offset. The method
        must be provided a struct.Struct() class instance which is used for
        the packing. 
        
        @param structObj: The struct.Struct() instance used for packing
        @param offset: The offset to pack the data to
        @param v1, v2 ...: The values to pack into buffer 
        @return The number of byte used by the packed data (structObj.size) for convenience
        '''
        # Do the pack into, since we can do this with a backing bytearray()
        absOffset = self.offset + offset
        structObj.pack_into(self._buffer, absOffset, *args)
        return structObj.size
        
    def unpack(self, structObj, offset = 0):
        '''
        Unpacks data from the underlying byte buffer, and returns the resulting data.
        The method must be provided a struct.Struct() class instance which is used for
        the un-packing.
        
        @param structObj: The struct.Struct() instance used for packing
        @param offset: The offset in the data to unpack from (default 0)
        @return Tuple containing the unpacked data 
        '''
        absOffset = self.offset + offset
        # XXX: buffer() is replaced by memoryview in Python 3, so this is Python 2 compatible only
        #      Sadly memoryview() in python 2.5+ is very dodgy and does not work with struct before version 2.7.5
        bufferRef = buffer(self._buffer, absOffset, structObj.size)
        return structObj.unpack_from(bufferRef)
        
    @property
    def view(self):
        '''
        Returns a memory view for the currently defined buffer. This is useful for
        working with this buffer as a memory view.
        '''
        return memoryview(self._buffer)[self.offset : self.offset + self.length]
        
    def __getitem__(self, index):
        if index >= 0 and index < self.length: 
            return self._buffer[index + self.offset]
        raise IndexError("Index out of bounds")
    
    def __setitem__(self, index, value):
        if index >= 0 and index < self.length: 
            self._buffer[index + self.offset] = value
            return
        raise IndexError("Index out of bounds")
        
    def __iter__(self):
        return iter(self.view)
    
    def __len__(self):
        return self.length 
        