# from bsddb import DBNoSuchFileError, DBPageNotFoundError
# work on osx . doesn't work on SG.
from bsddb3.db import DBNoSuchFileError , DBPageNotFoundError
import anydbm
import shelve
import Queue
import threading
import logging
import re
from smartlylib.exception import ChainedException
from smartlylib.service.Service import Service


logger = logging.getLogger(__name__)


class PersistenceException(Exception):
    pass


class SpecException(ChainedException):
    pass


class OpenShelve(object):
    """
    A context manager for opening a shelve database
    """

    # Use lock when opening file
    lock = threading.Lock()

    def __init__(self, file_name, flag='c'):
        self.file_name = file_name
        self.flag = flag

    def __enter__(self):
        try:
            self.lock.acquire()
            self.db = shelve.open(self.file_name, self.flag)
            logger.debug("Opened DB file: %s" % self.file_name)
            return self.db
        except DBNoSuchFileError:
            raise PersistenceException("Could not open DB, no such file: %s" % self.file_name)
        except anydbm.error as why:
            raise PersistenceException("Unexpected error when opening file: %s" % str(why))

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            self.db.close()
            logger.debug("Closed DB file: %s" % self.file_name)
            # Check if any exceptions have been raised
            # if exc_type is not None:
            #     raise PersistenceException(exc_val)
        except ValueError:
            pass
        finally:
            self.lock.release()


class PersistenceSpec(object):

    specs = []
    lock = threading.Lock()

    def __init__(self, spec_id, prefix, unique_attribute=None):
        """
        Create a persistence specification to use when persisting objects
        :param spec_id: A unique identifier of the persistence spec
        :type spec_id: str
        :param prefix: A unique prefix to be used when persisting the object to disk
        :param unique_attribute: An attribute of the object which is unique in the given context
        :type unique_attribute: str
        """
        self.spec_id = spec_id
        self.prefix = prefix
        self.unique_attribute = unique_attribute

    def __str__(self):
        return "%s (%s \"%s\")" % (self.spec_id, self.prefix, self.unique_attribute)

    @staticmethod
    def get_spec(spec_id):
        with PersistenceSpec.lock:
            for spec in PersistenceSpec.specs:
                if spec.spec_id == spec_id:
                    return spec
        raise SpecException("No spec matching ID '%s' was found" % spec_id)

    @staticmethod
    def get_formatted_obj(spec_id, obj):
        """
        Format an object for persistence using a persistence specification
        :param spec_id: A unique identifier of the persistence spec
        :type spec_id: str
        :param obj: The object to be persisted
        :type obj: object
        :return: dictionary with persistable data
        """
        spec = PersistenceSpec.get_spec(spec_id)
        if spec.unique_attribute is None:
            return {str(spec.prefix): obj}
        attributes = str(spec.unique_attribute).split('.')
        value = obj
        for attr in attributes:
            try:
                value = getattr(value, attr)
            except AttributeError:
                value = value[attr]
        return {str(spec.prefix) + str(value): obj}

    @staticmethod
    def get_prefix(spec_id):
        with PersistenceSpec.lock:
            for spec in PersistenceSpec.specs:
                if str(spec_id) == str(spec.spec_id):
                    return spec.prefix
        raise SpecException("No spec matching ID '%s' was found" % spec_id)

    @staticmethod
    def matches(spec_id, key):
        """
        Checks if spec from spec ID matches key
        :type spec_id: str
        :type key: str
        :return: True if match, False otherwise
        """
        return re.match(PersistenceSpec.get_prefix(spec_id), key) is not None

    def prefix_matches(self, key):
        return re.match(self.prefix, key) is not None

    @staticmethod
    def register(spec):
        """
        Register a new persistence spec
        :type spec: PersistenceSpec
        :raises SpecException if spec already exists
        """
        with PersistenceSpec.lock:
            for _spec in PersistenceSpec.specs:
                if str(_spec.spec_id) == str(spec.spec_id):
                    raise SpecException("Spec ID '%s' already exists in map" % spec.spec_id)
                if str(_spec.prefix) == str(spec.prefix):
                    raise SpecException("Spec prefix '%s' already exists in map" % spec.prefix)
            logger.debug("Registered new persistence spec: '%s'" % spec)
            PersistenceSpec.specs.append(spec)

    def suffix_matches(self, key, value):
        suffix = str(key[len(self.prefix):])
        return suffix == str(value)

    @staticmethod
    def unregister(spec_id):
        """
        Unregister persistence spec
        :type spec_id: str
        """
        with PersistenceSpec.lock:
            for spec in PersistenceSpec.specs:
                if str(spec.spec_id) == spec_id:
                    logger.debug("Unregistered persistence spec: '%s'" % spec)
                    PersistenceSpec.specs.remove(spec)
            raise SpecException("No such spec in spec map: '%s'" % spec_id)

    @staticmethod
    def unregister_all():
        with PersistenceSpec.lock:
            PersistenceSpec.specs = []


class PersistenceService(Service):
    lock = threading.Lock()
    q = Queue.Queue()
    cv = threading.Condition()

    def __init__(self, name, file_name):
        super(PersistenceService, self).__init__(name)

        self.file_name = file_name
        self.db = None

    def initialize(self):
        # Test if shelve is writable
        with OpenShelve(self.file_name):
            logger.debug("Confirmed that db is writable: %s" % self.file_name)

    def run(self):
        while self.isRunning():
            self.cv.acquire()
            while self.q.empty():
                try:
                    self.cv.wait()
                except RuntimeError:
                    pass
            self.write_queue_to_db()

    def purge(self):
        # Empty persistence queue
        self.cv.acquire()
        self.q.empty()
        logger.debug("Emptied persistence queue, remaining items in queue: %d" % self.q.qsize())
        # Empty database
        with OpenShelve(self.file_name) as db:
            logger.debug("Trying to purge database: %s" % self.file_name)
            try:
                for key in db:
                    del db[key]
                    logger.debug("Deleted key '%s' from database" % key)
            except (TypeError, KeyError, ValueError, DBPageNotFoundError) as why:
                logger.warning("Could not purge database '%s': %s" % (self.file_name, str(why)))
            finally:
                try:
                    self.cv.notify()
                except RuntimeError:
                    pass
                self.cv.release()

    def stop(self):
        super(PersistenceService, self).stop()
        PersistenceSpec.unregister_all()

    def write_queue_to_db(self):
        item = object
        with OpenShelve(self.file_name) as db:
            try:
                self.cv.acquire()
                # get item from queue
                item, callback = self.q.get()
                # check that item is dictionary
                if isinstance(item, dict):
                    # write object to db
                    for key in item.keys():
                        logger.debug("Trying to save [%s] to [%s] in %s" % (
                            str(item[key]), str(key), self.file_name
                        ))
                        db[key] = item[key]
                        logger.debug("Saved [%s: %s] to %s" % (str(key), str(item[key]), self.file_name))
                        logger.debug("Remaining items in queue: %d" % self.q.qsize())
                        db.sync()
                    # tell the queue that the task is done
                    self.q.task_done()
                    # run the callback function telling that the item has been stored
                    if callable(callback):
                        callback(item)
                else:
                    logger.error("Element in queue is not a dictionary: %s" % str(item))
            # no items in queue
            except Queue.Empty:
                pass
            except (DBPageNotFoundError, ValueError) as err:
                logger.error("Error storing element in DB: [%s]: %s" % (str(item), str(err)))
                # Re-open the shelve DB if closed
                try:
                    self.db = shelve.open(self.file_name)
                except (DBNoSuchFileError, anydbm.error) as err:
                    logger.error("Error re-opening DB: %s" % str(err))
                # put the item back in the queue
                self.q.put((item, None), block=True)
                # tell the queue that the item has been processed (though with errors)
                self.q.task_done()
            finally:
                self.cv.release()

    def enqueue(self, spec_id, obj, callback=None):
        """
        Enqueue a dictionary to be written to disk, call an optional callback when complete
        :param obj: object to be written to disk
        :type obj: object
        :param callback: The callback function to be called when object is written to disk
        :return:
        """
        self.cv.acquire()
        item = PersistenceSpec.get_formatted_obj(spec_id, obj)
        self.q.put((item, callback))
        logger.debug("Put object in persistence queue: %s (%s)" % (item, self.file_name))
        try:
            self.cv.notify()
        except RuntimeError:
            pass
        self.cv.release()

    def delete(self, persistence_spec_id, unique_value=None):
        """
        Delete an object matching persistence spec from database
        :param persistence_spec_id: The id of the spec to use for recognizing objects
        :type persistence_spec_id: str
        :param unique_value: Look for one object matching spec's unique attribute (see PersistenceSpec.unique_attribute)
        :raises PersistenceException if no matching object is found
        :return: Matching object
        """
        spec = PersistenceSpec.get_spec(persistence_spec_id)
        logger.debug("Trying to delete objects with spec ID=%s matching value=%s" % (persistence_spec_id, unique_value))
        with OpenShelve(self.file_name) as db:
            for key in db:
                if spec.prefix_matches(key) and unique_value is None or spec.suffix_matches(key, unique_value):
                    logger.info("Deleted object: %s" % str(db[key]))
                    del db[key]

    def get(self, persistence_spec_id, unique_value=None):
        """
        Get an object matching persistence spec from database
        :param persistence_spec_id: The id of the spec to use for recognizing objects
        :type persistence_spec_id: str
        :param unique_value: Look for one object matching spec's unique attribute (see PersistenceSpec.unique_attribute)
        :return: List of matching objects
        """
        logger.debug("Trying to get objects with spec ID=%s matching value=%s" % (persistence_spec_id, unique_value))
        keys = self.get_keys(persistence_spec_id, unique_value)
        with OpenShelve(self.file_name) as db:
            return [
                db[key] for key in keys
            ]

    def get_keys(self, persistence_spec_id, unique_value=None):
        """
        Get a list of keys from matching persistence spec from database
        :param persistence_spec_id: The id of the spec to use for recognizing objects
        :type persistence_spec_id: str
        :param unique_value: Look for one object matching spec's unique attribute (see PersistenceSpec.unique_attribute)
        :return: List of matching keys
        """
        spec = PersistenceSpec.get_spec(persistence_spec_id)
        logger.debug("Trying to get keys with spec ID=%s matching value=%s" % (persistence_spec_id, unique_value))
        with OpenShelve(self.file_name) as db:
            return [
                key for key in db if spec.prefix_matches(key) and
                unique_value is None or spec.suffix_matches(key, unique_value)
            ]

    def load(self):
        """
         Deserializing entire device registry from disk to memory
        """
        out = {}
        with OpenShelve(self.file_name) as db:
            logger.debug("Trying to load from file: %s" % str(self.file_name))
            try:
                for key in db:
                    try:
                        out[key] = db[key]
                        logger.debug("Loaded item from DB: [%s]: %s" % (str(key), str(out[key])))
                    except (ValueError, KeyError, anydbm.error, EOFError) as why:
                        logger.warning("Could not load from DB: %s" % str(why))
            except DBPageNotFoundError as why:
                logger.warning("Could not load DB file: %s" % str(why))
        logger.debug("Loaded dictionary from DB: %s" % str(out))
        return out
