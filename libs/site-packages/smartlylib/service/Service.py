'''
Created on Oct 2, 2013

@author: johnny
'''

import logging
from operator import itemgetter
from collections import deque
import threading

from smartlylib import collection
from smartlylib.concurrent import ThreadName
from smartlylib.exception import ChainedException


logger = logging.getLogger(__name__)

class Service(object):
    '''
    Abstract class that should be implemented by Services. The default class defines methods for
    life-cycle control, running and stopping the service. A service is runned by a ServiceRunner.
    '''
    
    SLEEP_STEP = 500
    
    def __init__(self, name):
        '''
        Intitializes state flags. DO NOT EVER MODIFY THIS IN A SUBCLASS!!!!
        '''
        self.name = name
        self._isStopped = threading.Event()
        self._isNotRunning = threading.Event()
        self._isNotRunning.set()
        self._serviceRunner = None
    
    def isRunning(self):
        '''
        Returns True if the current Service is currently running. This is the True running state
        of the service, and may return true if the service has been requested to stop but has not yet
        shut down.
        
        DO NOT OVERRIDE THIS METHOD
        '''
        return not self._isNotRunning.isSet()

    def isStopped(self):
        '''
        Returns true if the current service has been requested to stop, or is currently not running.
        
        Sub classes should check if they should continue to run by calling this method in the run()
        implementation. If the method returns true, the run() method should shut down and return.
        
        DO NOT OVERRIDE THIS METHOD 
        '''
        return self._isNotRunning.isSet() or self._isStopped.isSet()

    def stop(self):
        '''
        Method that is called to set the stopped event in the service
        '''
        self._isStopped.set()
            
    def waitStop(self, timeout = None):
        '''
        Method that blocks until stop() is called for service, or the timeout has elapsed
        '''
        return self._isStopped.wait(timeout)

    def initialize(self):
        '''
        This method is always called before the Service run() method is called. This should be used
        to prepare the service for execution, and should set up everything that is needed by the run 
        method to do it's work. 
        
        Any exceptions thrown in this method will prevent the Service from starting, and will 
        be re-thrown by the Service Runner. Any non-critical exception MUST be handled by the 
        implementation to prevent this behavior. If this feature is NOT needed, initialization
        can be done in the run() method (see documentation). 
        '''
        pass
        
    def run(self):
        raise NotImplementedError("Run Method is not implemented")

    def _sleep(self, sleepTime):
        '''
        DEPRECATED! This is the same method as waitStop(), which should be used instead!
        
        Convenience method that can be called by run() method implementation to sleep for a given
        delay. This will not block execution as time.sleep() does, and insures immediate return 
        when stopped.
        
        Will sleep for "sleepTime" (float) seconds, or unitl stop() is called 
        '''
        self._isStopped.wait(sleepTime)
        
    def __str__(self):
        return "Service:[" + self.name + "]"
    
    def __hash__(self):
        return hash(self.name)
    
    
ServiceState = collection.enum('START', 'RUN', 'STOP', 'IDLE')  

class ServiceObserver(object):
    '''
    Pure Virtual class defining methods common for a ServiceObserver
    
    An observer is notified when ever a service changes state, one callback for each state.
    '''
    
    def _notify(self, service, state, message = None):
        '''
        Called when a service state changes 
        '''
        if state == ServiceState.RUN or state == ServiceState.IDLE:
            logmethod = logger.info
        elif logger.isEnabledFor(logging.DEBUG):
            logmethod = logger.debug
        else: return
        
        if state in ServiceState.reverse:
            stateString = ServiceState.reverse[state]
        else:
            stateString = state
        msgString = (" Message: %s" % message) if message is not None else ""
        logmethod("SERVICE: Entered state [%s] for service [%s].%s" % (stateString, service.name, msgString))
        

    
class ServiceRunner(ServiceObserver):
    '''
    A Service runner is a class that runs a service. It will insure the service is initialized properbly,
    keep the service state updated and also make sure to restart a service if it fails (after a delay)
    '''

    DELAY_SLEEP = 0.5

    def __init__(self, service, recoverDelay = 10):
        '''
        Creates a new service runner for the provided Service implementation. The service will be kept alive
        and restarted after the provided delay if it fails. If the delay is 0 (or less) the service will never
        be restarted (for short delays, use a low delay value like 1 millisecond)
        
        @param service: The service to wrap in the runner 
        @param recoverDelay: (Optional) Recovery delay in seconds (float) 
        @param observer: (Optional) ServiceObserver instance that is notified about changes
        '''
        self.service = service
        self.service._serviceRunner = self
        self._recoverDelay = recoverDelay
        self._observer = None
        self._serviceWorker = None
        
        self._initEvent = threading.Event()
        self._initException = None
    
    def setObserver(self, observer):
        self._observer = observer
    
    def start(self):
        '''
        Starts the service, and blocks until the service is initialized. If the service is already running, the method simply returns.
        
        Note that a service that can be started and stopped as many times as wanted
        '''
        try:
            if (self.service.isRunning()):
                logger.warn("Service [%s] requested to start, but is already running" % self.service.name)
                return
            
            # Use a counter to insure Unique thread names
            threadName = "%s-%s" % (self.service.name, ThreadName.create("service-"))
            
            # Create the thread
            self._initEvent.clear()
            self._notify(self.service, ServiceState.START, "Service Thread: %s" % threadName)
            self._serviceWorker = threading.Thread(target=self._runService, name = threadName)
            self._serviceWorker.daemon = True
            
            self._serviceWorker.start()
            self._initEvent.wait()
        finally:
            if self._initException is not None:
                exc = self._initException
                self._initException = None
                raise exc
    
    def stop(self):
        '''
        Stops the service if it's currently running. If the service is not running, the method simply returns.
        '''
        if (self.service.isStopped()):
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug("Service ["+self.service.name+"] requested to stop, but is already stopped. Current running state: " + str(self.service.isRunning()))
            return

        # Simply set the service Stop event
        self._notify(self.service, ServiceState.STOP)
        self.service.stop()
    
    def waitShutdown(self, timeout = None):
        '''
        Blocks until the service has stopped. This method does not initiate the stop sequence itself, and
        requires stop to be called either before this method or in another thread. 
        '''
        return self.service._isNotRunning.wait(timeout)
    
    def _notify(self, service, state, message = None):
        if logger.isEnabledFor(logging.DEBUG):
            super(ServiceRunner, self)._notify(service, state, message)
        
        if self._observer is not None:
            try: self._observer._notify(service, state, message)
            except: logger.exception("Service Observer caused exception in notify")
    
    def __str__(self):
        return "ServiceRunner:" + str(self.service)
    
    def __hash__(self):
        return hash(self.service)
    
    def _runService(self):
        '''
        Internal service runner method
        '''
        try:
            self.service._isStopped.clear()
            while True:
                self.service._isNotRunning.clear()
                try:
                    # Run service initialization
                    self.service.initialize()
                except Exception as ex:
                    logger.exception("Service ["+self.service.name+"] failed to initialize due to an exception. Shutting down service.")
                    self._initException = ex
                    return
                finally:
                    # Make sure the init event is always set
                    self._initEvent.set()
    
                # Handle stopped service
                if self.service.isStopped():
                    break

                try:
                    # Execute the service
                    self._notify(self.service, ServiceState.RUN)
                    self.service.run()
                except Exception:
                    logger.exception("Service [%s] stopped due to an exception. Recover delay [%ss]", self.service.name, self._recoverDelay)
                    # If no recovery delay is set, simply let the exception pass
                    if self._recoverDelay <= 0:
                        raise
                finally:
                    self._notify(self.service, ServiceState.IDLE)

                # Make sure we stop the service if no recover delay has been set
                if self._recoverDelay <= 0:
                    self.stop()
                    break

                # Check for stopped service before entering recovery wait
                if self.service.isStopped():
                    break

                # Wait until recover delay runs out
                self.service._sleep(self._recoverDelay)
                
                # Handle stopped service
                if self.service.isStopped():
                    # We need to notify this, as the stop might have been triggered while waiting
                    self._notify(self.service, ServiceState.IDLE)
                    break
                
                if logger.isEnabledFor(logging.DEBUG):
                    logger.debug("Service ["+self.service.name+"] recovery initiated.")
                
        finally:
            # Make sure everything has been cleaned up
            self._initEvent.clear()
            self.service._isNotRunning.set()

            
class ServiceRegisterException(ChainedException): pass
    
class ServiceManager(ServiceObserver):
    '''
    The Service Manager is used to manage common service execution
    
    The service manager will take care of starting and stopping all registered services
    in addition to mechanisms for checking and reporting clean and forced shutdowns.
    
    When a service is registered it is wrapped in a ServiceRunner instance, unless a
    service runner instance is registered.
    '''   
    
    def __init__(self, managerName, defaultRecoverDelay = 10):
        self.managerName = managerName
        self._defaultRecoverDelay = defaultRecoverDelay
        
        self._observerSet = set()
        self._serviceRunnerLock = threading.Lock()
        self._serviceRunnerMap = dict()
        
        self._executionLock = threading.Lock()
        self._executionQueue = []
        self._executionStage = None
        
        self._currentState = ServiceState.IDLE
        self._isStartupComplete = threading.Event()
        self._isShutdownComplete = threading.Event()
        self._isShutdownComplete.set()
        
    def getState(self):
        return self._currentState
        
    def registerObserver(self, observer):
        '''
        Registers observers for the Service Manager state. This can be used to monitor
        the state of the service manager itself, which can be useful to perform
        actions according to this.
        '''
        if not isinstance(observer, ServiceObserver):
            raise ValueError("Provided object does not implement ServcieObserver")
        self._observerSet.add(observer)
        
    def register(self, service, recoverDelay = 10, priority = 20 ):
        '''
        Registers a service in the Service Manager
        
        Services can optionally be given a priority numbers, where lower numbers are started 
        (and confirmed running) before higher numbers. If two or more services have the same 
        number, they are started in a random order (but still in order with different 
        priority services). During shutdown the order is reversed, and higher priority numbers
        are stopped before lower ones.
        
        Registering services while the manager is running, will start them immediately (unless
        they are already running).
        
        @param service: Service or ServiceRunner instance to register
        @param recoverDelay: The recover delay for the service (ignored for ServiceRunner intances) 
        @param priority: (Default 20) Used to define the order to start and stop services in  
        '''
        # Prepare the service
        if isinstance(service, ServiceRunner):
            serviceRun = service
        else:
            serviceRun = ServiceRunner(service, recoverDelay) 
        
        with self._serviceRunnerLock:
            serviceRun.setObserver(self)
            
            if serviceRun.service.name in self._serviceRunnerMap:
                raise ServiceRegisterException("Service [%s] is already registered" % serviceRun.service.name)
                
            # Register the runner in the map
            self._serviceRunnerMap[serviceRun.service.name] = (priority, serviceRun)
            
            # Check if service is running, and start it if not
            if self._currentState == ServiceState.RUN and not serviceRun.service.isRunning():
                serviceRun.start()
                
    def start(self):
        '''
        Starts all registered services and enables running state
        '''
        with self._serviceRunnerLock:
            # Check that we are not already running
            if not self._isShutdownComplete.is_set(): 
                logger.warn("Service Manager requested to start, but is already started...")
                return
            
            # Clear the shutdown state
            self._updateState(ServiceState.START)
            self._isShutdownComplete.clear()
            self._isStartupComplete.clear()

            # Extract all values from service runner map, and sort them
            serviceEntries = sorted(self._serviceRunnerMap.values(), key = itemgetter(0))
            
            # Update the execution list, and start execution
            with self._executionLock:
                self._executionQueue = self._buildExecutionQueue(serviceEntries)
        
        # Process the execution list
        self._processExecutionQueue()

            
    def stop(self):
        '''
        Signals all running services to stop 
        '''
        # Double checked lock to avoid deadlocks
        with self._serviceRunnerLock:
            if self._currentState != ServiceState.RUN: return
            
            # Set state to STOP
            self._updateState(ServiceState.STOP)
            
            # Extract all values from service runner map, and sort them
            serviceEntries = reversed(sorted(self._serviceRunnerMap.values(), key = itemgetter(0)))
            
            # Update the execution list, and start execution
            with self._executionLock:
                self._executionQueue = self._buildExecutionQueue(serviceEntries)
        
        # Process the execution list
        self._processExecutionQueue()


    def waitStartup(self, timeout = None):
        '''
        Waits for all services to start up and then returns True.  
        If timeout is reached before startup is complete, False is returned
        @param timeout: Number of seconds to wait before timeout. None (default) means no timeout 
        '''
        return self._isStartupComplete.wait(timeout)
    
    def waitShutdown(self, timeout = None):
        '''
        Waits for all services to shut down and then returns True.  
        If timeout is reached before shutdown is complete, False is returned
        @param timeout: Number of seconds to wait before timeout. None (default) means no timeout 
        '''
        return self._isShutdownComplete.wait(timeout)
            
    def _updateState(self, newState):
        with self._executionLock:
            self._currentState = newState
            if newState == ServiceState.RUN:
                self._isStartupComplete.set()
            elif newState == ServiceState.IDLE:
                self._isShutdownComplete.set()
        
        # Notify the state change
        for observer in self._observerSet:
            observer._notify(self, newState)
            
    def _notify(self, service, state, message = None):
        '''
        This is called as services changes states
        '''
        # We are only interested in RUN and IDLE state reports
        if state != ServiceState.RUN and state != ServiceState.IDLE: 
            return
        
        with self._executionLock:
            # If there is no services waiting for processing, we simply return
            if self._executionStage == None: return
            
            # Check for proper state reports
            if state == ServiceState.RUN and self._currentState == ServiceState.START:
                isRunning = True
            elif state == ServiceState.IDLE and self._currentState == ServiceState.STOP:
                isRunning = False
            else:
                return
            
            # Remove service from stage 
            self._executionStage[1].discard(service)
            
            # If we have more entries in the set, we need to return
            if len(self._executionStage[1]) > 0: return
            
        # After releasing lock, we need to process next priority level
        if self._processExecutionQueue(): return
        
        # Now we have confirmed all running or stopped, so update Events
        if isRunning:
            self._updateState(ServiceState.RUN) 
        else:
            self._updateState(ServiceState.IDLE) 
        
         
    def _buildExecutionQueue(self, serviceEntries):
        # Now iterate through the entries and organize them in a startup list
        startupQueue = deque([])
        currPriority = None
        for priority, serviceRunner in serviceEntries:
            # If priority has changed, update startupList index
            if currPriority != priority:
                currPriority = priority
                
                currentQueueEntry = (priority, set())
                startupQueue.append(currentQueueEntry)
                
            # Now we can insert into the current list entry
            currentQueueEntry[1].add(serviceRunner)
        
        return startupQueue
       
    def _processExecutionQueue(self):
        '''
        Processes the execution list for starting or stopping services
        '''
        # Check if we should start or stop entries in list
        with self._executionLock:
            # If execution queue is empty, we return
            if len(self._executionQueue) == 0:
                self._executionStage = None 
                return False
            
            # Determine the mode
            if self._currentState == ServiceState.START:
                isStartup = True
            elif self._currentState == ServiceState.STOP:
                isStartup = False
            else:
                logger.warn("Execution queue is NOT empty, but Manager state is [%s]. THIS SHOULD NOT HAPPEN!" % ServiceState.reverse[self._currentState])
                return True
            
            # Pop the next entry in queue
            processStage = self._executionQueue.popleft()
            if logger.isEnabledFor(logging.DEBUG):
                execString = "starting" if isStartup else "stopping"
                logger.debug("===== Service manager [%s] %s Services at priority level [%s] =====" % (self.managerName, execString, processStage[0]))
            
            # Send signal to all entries
            executionStage = (processStage[0], set())
            for entry in processStage[1]:
                try:
                    if isStartup: entry.start()
                    else: entry.stop()
                    
                    # Only add stage to set if it's handled (no exception) and is not already idle.
                    executionStage[1].add(entry.service)
                except:
                    logger.exception("Unable to start service [%s] due to an exception. Ignoring Service..." % entry.service.name)
            
            self._executionStage = executionStage
            
            return True
