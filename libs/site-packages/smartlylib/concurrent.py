'''
Created on May 23, 2014

@author: johnny
'''
import threading, logging, traceback, sys
from smartlylib import debugutil

class ThreadName(object):
    '''
    Static class used to name threads
    '''

    NAME_LOCK = threading.Lock()
    NAME_MAP = {}

    @staticmethod
    def create(basename):
        '''
        Creates a thread name given the base name
        '''
        with ThreadName.NAME_LOCK:
            index = 0
            if basename in ThreadName.NAME_MAP:
                index = ThreadName.NAME_MAP[basename]
        
            index = (index % 0x7FFFFFFF) + 1
            ThreadName.NAME_MAP[basename] = index
            return basename + str(index)

logger = logging.getLogger("CONCURRENT-DEBUG")

class LockDebug(object):
    
    def __init__(self, wrappedLock = None):
        self.lock = wrappedLock if wrappedLock is not None else threading.Lock()
        self._isDebug = logger.isEnabledFor(logging.DEBUG)
        if self._isDebug:
            self._lockId = ThreadName.create("LCKDBG:")
            logger.debug(self._lockId + "-CREATED: ["+str(threading.current_thread())+"]\n=== Trace:\n" + debugutil.stack())
        else:
            self._lockId = ''
    
    def acquire(self, blocking = True):
        if self._isDebug: 
            logger.debug(self._lockId + "-REQUEST: ["+str(threading.current_thread())+"]\n=== Trace:\n" + debugutil.stack(2))
        # Acquire the lock and report the result
        acquireResult = self.lock.acquire()
        if self._isDebug: logger.debug(self._lockId + "-RESULT["+str(acquireResult)+"]: ["+str(threading.current_thread())+"]")
        return acquireResult
    
    def release(self):
        self.lock.release()
        if self._isDebug: logger.debug(self._lockId + "-RELEASE: ["+str(threading.current_thread())+"]")
    
    # To support "with" statement
    __enter__ = acquire
        
    def __exit__(self, t, v, tb):
        self.release()
    
    
class ThreadDebug(object):
    '''
    Contains methods for Thread related debugging
    '''
        
    @staticmethod
    def dumpThreadStack():
        '''
        Dumps all current thread stack traces to a string, which is returned.
        '''
        # Create a map of thread IDs
        threadMap = dict()
        for activeThread in threading.enumerate():
            threadMap[str(activeThread.ident)] = activeThread.name
        
        stackDump = "*** STACKTRACE - START ***\n"
        for threadId, stack in sys._current_frames().items():
            threadName = ""
            threadIdStr = str(threadId)
            if threadIdStr in threadMap:
                threadName = " [%s]" % threadMap[threadIdStr]
                
            stackDump += "\n# ThreadID: %s%s\n" % (threadIdStr, threadName)
            
            threadStackList = traceback.format_stack(stack)
            for threadStackEntry in threadStackList:
                stackDump += threadStackEntry

        stackDump += "\n*** STACKTRACE - END ***\n"
        return stackDump
        

